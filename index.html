<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galaxy Christmas Tree (Pro)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; box-sizing: border-box; }
        .header { text-align: center; margin-top: 20px; }
        h1 { margin: 0; font-size: 2.2rem; letter-spacing: 5px; color: #FFD700; text-shadow: 0 0 20px #FFD700; font-family: "Times New Roman", serif; }
        .controls-info { background: rgba(10, 5, 0, 0.7); backdrop-filter: blur(8px); padding: 20px; border: 1px solid rgba(255, 215, 0, 0.3); color: #dcb; pointer-events: auto; max-width: 320px; font-size: 0.85rem; box-shadow: 0 10px 30px rgba(0,0,0,0.8); }
        .controls-info h3 { margin: 0 0 10px 0; color: #FFD700; text-transform: uppercase; }
        .btn { display: inline-block; margin-top: 15px; width: 100%; box-sizing: border-box; background: linear-gradient(180deg, #b8860b, #8B6508); border: 1px solid #FFD700; color: #fff; padding: 10px 0; text-align: center; cursor: pointer; font-weight: bold; pointer-events: auto; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #FFD700; }
        #start-btn { margin-top: 30px; padding: 15px 40px; font-size: 1.2rem; display: none; cursor: pointer; background: transparent; color: #FFD700; border: 2px solid #FFD700; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0.3; transform: scaleX(-1); border: 1px solid #FFD700; z-index: 5; }
        #hand-cursor { position: absolute; width: 20px; height: 20px; border: 2px solid #FFD700; transform: translate(-50%, -50%) rotate(45deg); box-shadow: 0 0 15px #FFD700; z-index: 20; display: none; pointer-events: none; }
    </style>
</head>
<body>
    <audio id="bgm" src="music.mp3" loop></audio>
    <div id="loading">
        <div id="loading-text" style="font-size: 2rem;">GALAXY TREE</div>
        <div id="loading-sub" style="color:#666; margin-top:10px;">LOADING 20,000 PARTICLES...</div>
        <button id="start-btn">ENTER</button>
    </div>
    <div id="ui-layer">
        <div class="header"><h1>MERRY CHRISTMAS</h1></div>
        <div class="controls-info">
            <h3>Gesture Controls</h3>
            <ul><li>âœŠ <b>Fist</b> : Assemble Tree</li><li>ğŸ– <b>Open</b> : Galaxy Explosion</li><li>ğŸ¤ <b>Pinch</b> : View Photo</li><li>ğŸ‘‹ <b>Wave</b> : Rotate</li></ul>
            <label class="btn">UPLOAD MEMORIES <input type="file" id="file-input" multiple accept="image/*" style="display:none"></label>
        </div>
    </div>
    <div id="hand-cursor"></div>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/", "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm", "gsap": "https://unpkg.com/gsap@3.12.5/index.js" } }</script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        // ğŸ”¥ æ ¸å¿ƒå‡çº§ï¼šç²’å­æ•°é‡æ¿€å¢åˆ° 20,000
        const CONFIG = {
            particleCount: 20000, 
            photoCount: 15,
            treeHeight: 40,
            treeRadius: 16,
            colors: [0xffaa00, 0xff0033, 0x00ff88, 0xffffff] // é‡‘ã€çº¢ã€ç»¿ã€ç™½
        };

        let scene, camera, renderer, composer;
        let treeSystem, snowSystem, topStar; // ç²’å­ç³»ç»Ÿ
        let photoMeshes = []; 
        let dummyTexture;
        let state = 'TREE'; 
        let handLandmarker;
        let gestureCooldown = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ğŸŒŸ ç²’å­æ•°æ®å­˜å‚¨ (BufferAttributes)
        // æˆ‘ä»¬ä¸å­˜ Meshï¼Œåªå­˜åæ ‡æ•°æ®ï¼Œæ€§èƒ½æå‡ 100 å€
        let particlePositions, particleTargetTree, particleTargetScatter;

        async function init() {
            try {
                setupScene();
                createParticleTexture(); // åˆ¶ä½œå‘å…‰ç‚¹è´´å›¾
                createPhotoTexture();    // åˆ¶ä½œæ‹ç«‹å¾—è´´å›¾
                createTreeParticles();   // âœ¨ æ ¸å¿ƒï¼šåˆ›å»º2ä¸‡ä¸ªç²’å­æ ‘
                createPhotoCloud();
                createSnow();
                
                await setupWebcam();
                await setupMediaPipe();

                document.getElementById('loading').style.display = 'none'; // ç®€åŒ–åŠ è½½é€»è¾‘
                document.getElementById('start-btn').click(); // è‡ªåŠ¨è§¦å‘(å¦‚æœæœ‰äº¤äº’é™åˆ¶åˆ™éœ€æ‰‹åŠ¨)
                
                document.getElementById('start-btn').style.display = 'block';
                document.getElementById('start-btn').addEventListener('click', () => {
                   document.getElementById('loading').style.display = 'none';
                   const bgm = document.getElementById('bgm'); bgm.volume=0.6; bgm.play().catch(()=>{});
                   animate();
                });
                
                window.addEventListener('resize', onWindowResize);
                document.getElementById('file-input').addEventListener('change', handleUpload);

            } catch (e) { console.error(e); alert("Init Error: " + e.message); }
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015); // çº¯é»‘èƒŒæ™¯é…åˆç²’å­

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 80); camera.lookAt(0, 20, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // ç²’å­å¤šæ—¶å…³æ‰æŠ—é”¯é½¿æé€Ÿ
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            // âœ¨ å¼ºåŠ›è¾‰å…‰ï¼šç²’å­æ ‘çš„çµé­‚
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 2.0; bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        let dotTexture;
        function createParticleTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            dotTexture = new THREE.CanvasTexture(cvs);
        }

        function createPhotoTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 300; cvs.height = 380;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,300,380); // ç™½è¾¹æ¡†
            ctx.fillStyle = '#111'; ctx.fillRect(15,15,270,270); // é»‘åº•
            ctx.fillStyle = '#333'; ctx.font = '20px Courier'; ctx.textAlign = 'center';
            ctx.fillText("WINTER MEMORY", 150, 340);
            dummyTexture = new THREE.CanvasTexture(cvs);
        }

        // ğŸ„ æ ¸å¿ƒï¼šç”¨ Points åˆ›å»ºç²’å­æ ‘ (é«˜æ€§èƒ½)
        function createTreeParticles() {
            const geometry = new THREE.BufferGeometry();
            const cnt = CONFIG.particleCount;
            
            const posArray = new Float32Array(cnt * 3);     // å½“å‰ä½ç½®
            const colorArray = new Float32Array(cnt * 3);   // é¢œè‰²
            
            // æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªé¢å¤–çš„æ•°ç»„æ¥å­˜â€œç›®æ ‡ä½ç½®â€
            particleTargetTree = new Float32Array(cnt * 3);
            particleTargetScatter = new Float32Array(cnt * 3);

            const tempVec = new THREE.Vector3();
            const color = new THREE.Color();

            for(let i=0; i<cnt; i++) {
                // 1. æ ‘å½¢æ€ (Tree Target)
                const hPercent = Math.random();
                const y = Math.pow(hPercent, 0.8) * CONFIG.treeHeight;
                const r = Math.sqrt(Math.random()) * (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius;
                const angle = Math.random() * Math.PI * 2;
                
                // èºæ—‹å¹²æ‰° (è®©æ ‘çœ‹èµ·æ¥æ›´æœ‰çº¹ç†)
                const spiral = angle + y * 0.5; 
                
                particleTargetTree[i*3]   = Math.cos(spiral) * r;
                particleTargetTree[i*3+1] = y;
                particleTargetTree[i*3+2] = Math.sin(spiral) * r;

                // 2. çˆ†ç‚¸å½¢æ€ (Scatter Target) - æ˜Ÿç³»çŠ¶
                const sr = 30 + Math.random() * 50;
                const sAngle = Math.random() * Math.PI * 2;
                // æ‰å¹³åŒ–åˆ†å¸ƒåƒæ˜Ÿç³»
                particleTargetScatter[i*3]   = Math.cos(sAngle) * sr;
                particleTargetScatter[i*3+1] = (Math.random()-0.5) * 20 + 20; 
                particleTargetScatter[i*3+2] = Math.sin(sAngle) * sr;

                // 3. åˆå§‹ä½ç½® (è®¾ä¸º Scatterï¼Œåé¢åŠ¨ç”»èšåˆ)
                posArray[i*3]   = particleTargetTree[i*3];
                posArray[i*3+1] = particleTargetTree[i*3+1];
                posArray[i*3+2] = particleTargetTree[i*3+2];

                // 4. é¢œè‰²
                color.setHex(CONFIG.colors[Math.floor(Math.random()*CONFIG.colors.length)]);
                colorArray[i*3] = color.r;
                colorArray[i*3+1] = color.g;
                colorArray[i*3+2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            // æè´¨ï¼šä½¿ç”¨ AdditiveBlending å®ç°å…‰ç‚¹å åŠ 
            const material = new THREE.PointsMaterial({
                size: 0.6,
                map: dotTexture,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            treeSystem = new THREE.Points(geometry, material);
            scene.add(treeSystem);

            // ğŸŒŸ æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(2, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            topStar = new THREE.Mesh(starGeo, starMat);
            topStar.position.set(0, CONFIG.treeHeight+1, 0);
            
            // æ˜Ÿæ˜Ÿçš„å…‰æ™•
            const haloSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: dotTexture, color: 0xffaa00, blending: THREE.AdditiveBlending 
            }));
            haloSprite.scale.set(15,15,1);
            topStar.add(haloSprite);
            scene.add(topStar);
        }

        function createPhotoCloud() {
            const geo = new THREE.PlaneGeometry(4, 4.8);
            for(let i=0; i<CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: dummyTexture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                
                // æ‹ç«‹å¾—ç…§ç‰‡ç¨å¾®æµ®åœ¨ç²’å­è¡¨é¢
                const t = i/CONFIG.photoCount;
                const y = (1-t) * (CONFIG.treeHeight-5) + 2;
                const r = (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius + 2; 
                const angle = i * 2.5;

                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*80, Math.random()*40+10, (Math.random()-0.5)*80);

                mesh.position.copy(treePos);
                mesh.lookAt(0, y, 0);
                mesh.userData = { treePos, scatterPos };
                
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createSnow() {
            const count = 1000;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) pos.push((Math.random()-0.5)*100, Math.random()*80, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 0.8, map: dotTexture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        // ğŸ¥ åŠ¨ç”»çŠ¶æ€æœº (æ ¸å¿ƒé€»è¾‘ä¿®æ”¹)
        // å› ä¸ºæˆ‘ä»¬ç”¨çš„æ˜¯ Pointsï¼Œä¸èƒ½ç›´æ¥ gsap mesh.position
        // æˆ‘ä»¬éœ€è¦è‡ªå·±å†™ä¸€ä¸ªæ’å€¼å™¨
        let animationProgress = { val: 0 }; // 0 = Tree, 1 = Scatter

        function switchState(newState) {
            if (state === newState) return;
            state = newState;
            
            if (state === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 25, z: 80, duration: 2 });
                gsap.to(animationProgress, { val: 0, duration: 2, ease: "power2.inOut" });
                // ç…§ç‰‡é£å›
                photoMeshes.forEach(m => gsap.to(m.position, { ...m.userData.treePos, duration: 2 }));
            } else if (state === 'SCATTER') {
                gsap.to(animationProgress, { val: 1, duration: 2.5, ease: "power2.out" }); // æ…¢ä¸€ç‚¹ç‚¸å¼€
                // ç…§ç‰‡ç‚¸å¼€
                photoMeshes.forEach(m => gsap.to(m.position, { ...m.userData.scatterPos, duration: 2 }));
            }
        }

        function handleUpload(e) {
            const files = Array.from(e.target.files);
            let idx = 0;
            files.forEach(file => {
                if (idx >= photoMeshes.length) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        photoMeshes[idx].material.map = tex;
                        photoMeshes[idx].material.needsUpdate = true;
                        idx++;
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        // æ‰‹åŠ¿éƒ¨åˆ†ä¿æŒä¸å˜ï¼Œå› ä¸ºé€»è¾‘æ˜¯é€šç”¨çš„
        async function setupWebcam() {
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
            video.srcObject = stream;
            return new Promise(r => video.onloadeddata = r);
        }
        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
        }
        function detectGesture(landmarks) {
            const lm = landmarks[0];
            const palmX = 1-lm[9].x, palmY = lm[9].y;
            const cursor = document.getElementById('hand-cursor');
            cursor.style.display='block'; cursor.style.left=(palmX*100)+'%'; cursor.style.top=(palmY*100)+'%';
            
            const wrist = lm[0];
            const tips = [lm[8],lm[12],lm[16],lm[20]];
            const avgDist = tips.reduce((s,t) => s+Math.hypot(t.x-wrist.x,t.y-wrist.y,t.z-wrist.z),0)/4;
            const now = Date.now();
            
            if (now-gestureCooldown > 600) {
                if(avgDist<0.28) { if(state!=='TREE'){ switchState('TREE'); gestureCooldown=now;} cursor.style.borderColor='red'; }
                else if(avgDist>0.45 && state==='TREE'){ switchState('SCATTER'); gestureCooldown=now; cursor.style.borderColor='gold'; }
            }
            if(state==='SCATTER' && avgDist>0.4) gsap.to(scene.rotation, {y: (palmX-0.5)*3, x: (palmY-0.5)*0.5, duration: 1});
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            const video = document.getElementById('webcam');
            if (handLandmarker && video.currentTime > 0) {
                const res = handLandmarker.detectForVideo(video, performance.now());
                if (res.landmarks && res.landmarks.length) detectGesture(res.landmarks);
                else document.getElementById('hand-cursor').style.display = 'none';
            }

            // ğŸ‡ ç²’å­ç³»ç»Ÿæ ¸å¿ƒåŠ¨ç”» (Lerp)
            // æ‰‹åŠ¨è®¡ç®—æ•°ä¸‡ä¸ªç‚¹çš„ä½ç½®æ’å€¼
            if (treeSystem) {
                const pos = treeSystem.geometry.attributes.position;
                const t = animationProgress.val; // 0 to 1
                
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const idx = i*3;
                    const tx = particleTargetTree[idx];
                    const ty = particleTargetTree[idx+1];
                    const tz = particleTargetTree[idx+2];
                    
                    const sx = particleTargetScatter[idx];
                    const sy = particleTargetScatter[idx+1];
                    const sz = particleTargetScatter[idx+2];
                    
                    // çº¿æ€§æ’å€¼ (Lerp)
                    // pos = tree * (1-t) + scatter * t
                    pos.array[idx]   = tx * (1-t) + sx * t;
                    pos.array[idx+1] = ty * (1-t) + sy * t;
                    pos.array[idx+2] = tz * (1-t) + sz * t;

                    // å¢åŠ ä¸€ç‚¹ç‚¹åŠ¨æ€é—ªçƒ (Noise)
                    if(state==='TREE') {
                        pos.array[idx+1] += Math.sin(time*2 + tx)*0.02; 
                    }
                }
                pos.needsUpdate = true;
                
                // æ•´ä½“æ—‹è½¬
                if(state==='TREE') scene.rotation.y += 0.001;
            }
            
            // é›ªèŠ±
            if(snowSystem) {
                const pos = snowSystem.geometry.attributes.position;
                for(let i=0; i<1000; i++) {
                    pos.array[i*3+1] -= 0.1;
                    if(pos.array[i*3+1] < -10) pos.array[i*3+1] = 60;
                }
                pos.needsUpdate = true;
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
