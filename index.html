<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galaxy Christmas Tree - Director's Cut</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; box-sizing: border-box; }
        .header { text-align: center; margin-top: 20px; }
        h1 { margin: 0; font-size: 2.2rem; letter-spacing: 5px; color: #FFD700; text-shadow: 0 0 20px #FFD700; font-family: "Times New Roman", serif; }
        .controls-info { background: rgba(10, 5, 0, 0.7); backdrop-filter: blur(8px); padding: 20px; border: 1px solid rgba(255, 215, 0, 0.3); color: #dcb; pointer-events: auto; max-width: 320px; font-size: 0.85rem; box-shadow: 0 10px 30px rgba(0,0,0,0.8); }
        .controls-info h3 { margin: 0 0 10px 0; color: #FFD700; text-transform: uppercase; }
        .btn { display: inline-block; margin-top: 15px; width: 100%; box-sizing: border-box; background: linear-gradient(180deg, #b8860b, #8B6508); border: 1px solid #FFD700; color: #fff; padding: 10px 0; text-align: center; cursor: pointer; font-weight: bold; pointer-events: auto; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #FFD700; }
        #start-btn { margin-top: 30px; padding: 15px 40px; font-size: 1.2rem; display: none; cursor: pointer; background: transparent; color: #FFD700; border: 2px solid #FFD700; transition: all 0.3s;}
        #start-btn:hover { background: #FFD700; color: #000; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0.3; transform: scaleX(-1); border: 1px solid #FFD700; z-index: 5; }
        #hand-cursor { position: absolute; width: 20px; height: 20px; border: 2px solid #FFD700; transform: translate(-50%, -50%) rotate(45deg); box-shadow: 0 0 15px #FFD700; z-index: 20; display: none; pointer-events: none; transition: all 0.2s; }
    </style>
</head>
<body>
    <audio id="bgm" src="music.mp3" loop></audio>
    <div id="loading">
        <div id="loading-text" style="font-size: 2rem;">GALAXY TREE</div>
        <div id="loading-sub" style="color:#666; margin-top:10px;">LOADING UNIVERSE...</div>
        <button id="start-btn">ENTER GALAXY</button>
    </div>
    <div id="ui-layer">
        <div class="header"><h1>MERRY CHRISTMAS</h1></div>
        <div class="controls-info">
            <h3>Gesture Controls</h3>
            <ul><li>‚úä <b>Fist</b> : Assemble Tree</li><li>üñê <b>Open</b> : Galaxy Explosion</li><li>ü§è <b>Pinch</b> : View Photo</li><li>üëã <b>Wave</b> : Rotate</li></ul>
            <label class="btn">UPLOAD MEMORIES <input type="file" id="file-input" multiple accept="image/*" style="display:none"></label>
        </div>
    </div>
    <div id="hand-cursor"></div>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/", "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm", "gsap": "https://unpkg.com/gsap@3.12.5/index.js" } }</script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        const CONFIG = {
            particleCount: 20000, 
            photoCount: 15,
            treeHeight: 40,
            treeRadius: 16,
            colors: [0xffaa00, 0xff0033, 0x00ff88, 0xffffff] 
        };

        let scene, camera, renderer, composer;
        let treeSystem, snowSystem, topStar;
        let photoMeshes = []; 
        let dummyTexture;
        let state = 'TREE'; 
        let zoomedPhoto = null;
        let handLandmarker;
        let gestureCooldown = 0;
        let isAnimating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Ê†∏ÂøÉÊï∞ÊçÆÊï∞ÁªÑ
        let particleTargetTree;     // Ê†ëÂΩ¢ÊÄÅÁöÑÂùêÊ†á
        let particleTargetScatter;  // ÁàÜÁÇ∏ÂΩ¢ÊÄÅÁöÑÂùêÊ†á (Âè™Â≠òYËΩ¥)

        async function init() {
            try {
                const loadSub = document.getElementById('loading-sub');
                loadSub.innerText = "INITIALIZING GPU...";
                
                setupScene();
                createParticleTexture(); 
                createPhotoTexture();    
                createTreeParticles();   
                createPhotoCloud();
                createSnow();
                
                loadSub.innerText = "LOADING CAMERA...";
                await setupWebcam();
                await setupMediaPipe();

                loadSub.style.display = 'none';
                document.getElementById('loading-text').innerText = "READY";
                
                const startBtn = document.getElementById('start-btn');
                startBtn.style.display = 'block';
                
                startBtn.addEventListener('click', () => {
                   document.getElementById('loading').style.display = 'none';
                   const bgm = document.getElementById('bgm'); 
                   bgm.volume = 0.6; 
                   bgm.play().catch(e => console.log("Audio play blocked"));
                   
                   if (!isAnimating) {
                       isAnimating = true;
                       animate();
                   }
                });
                
                window.addEventListener('resize', onWindowResize);
                document.getElementById('file-input').addEventListener('change', handleUpload);

            } catch (e) { console.error(e); alert("Init Error: " + e.message); }
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 80); camera.lookAt(0, 20, 0);

            // ‰øÆÂ§ç: ÊãºÂÜôÈîôËØØ antiasias -> antialias
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 2.0; bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        let dotTexture;
        function createParticleTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            dotTexture = new THREE.CanvasTexture(cvs);
        }

        function createPhotoTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 300; cvs.height = 380;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,300,380); 
            ctx.fillStyle = '#111'; ctx.fillRect(15,15,270,270); 
            ctx.fillStyle = '#333'; ctx.font = '20px Courier'; ctx.textAlign = 'center';
            ctx.fillText("WINTER MEMORY", 150, 340);
            dummyTexture = new THREE.CanvasTexture(cvs);
        }

        function createTreeParticles() {
            const geometry = new THREE.BufferGeometry();
            const cnt = CONFIG.particleCount;
            
            const posArray = new Float32Array(cnt * 3);     
            const colorArray = new Float32Array(cnt * 3);   
            // scatterData: x=radius, y=angle, z=speed
            const scatterData = new Float32Array(cnt * 3); 
            
            particleTargetTree = new Float32Array(cnt * 3);
            // ‰øÆÂ§ç: ‰ΩøÁî®Ëøô‰∏™Êï∞ÁªÑÂ≠òÂÇ®Âõ∫ÂÆöÁöÑÁàÜÁÇ∏YËΩ¥È´òÂ∫¶
            particleTargetScatter = new Float32Array(cnt * 3); 

            const color = new THREE.Color();

            for(let i=0; i<cnt; i++) {
                // 1. Ê†ëÂΩ¢ÊÄÅÊï∞ÊçÆ
                const hPercent = Math.random();
                const y = Math.pow(hPercent, 0.8) * CONFIG.treeHeight;
                const r = Math.sqrt(Math.random()) * (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius;
                const angle = Math.random() * Math.PI * 2;
                const spiral = angle + y * 0.5; 
                
                particleTargetTree[i*3]   = Math.cos(spiral) * r;
                particleTargetTree[i*3+1] = y;
                particleTargetTree[i*3+2] = Math.sin(spiral) * r;
                
                // 2. ÁàÜÁÇ∏ÂΩ¢ÊÄÅÊï∞ÊçÆ (È¢ÑÂÖàËÆ°ÁÆóÂ•Ω)
                scatterData[i*3] = 30 + Math.random() * 50; // ÂçäÂæÑ
                scatterData[i*3+1] = Math.random() * Math.PI * 2; // ËßíÂ∫¶
                scatterData[i*3+2] = (Math.random() - 0.5) * 0.01; // ÊóãËΩ¨ÈÄüÂ∫¶

                // ‰øÆÂ§ç: Âú®ËøôÈáåÂõ∫ÂÆö Y ËΩ¥È´òÂ∫¶ÔºåËÄå‰∏çÊòØÂú® animate ÈáåÈöèÊú∫ÁîüÊàê
                particleTargetScatter[i*3+1] = (Math.random() - 0.5) * 20 + 20;

                // 3. ÂàùÂßã‰ΩçÁΩÆËÆæ‰∏∫Ê†ë
                posArray.set([particleTargetTree[i*3], particleTargetTree[i*3+1], particleTargetTree[i*3+2]], i*3);

                color.setHex(CONFIG.colors[Math.floor(Math.random()*CONFIG.colors.length)]);
                colorArray.set([color.r, color.g, color.b], i*3);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.setAttribute('scatterData', new THREE.BufferAttribute(scatterData, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.6, map: dotTexture, vertexColors: true, transparent: true,
                opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending
            });

            treeSystem = new THREE.Points(geometry, material);
            scene.add(treeSystem);

            // ‰∏äÂ∏ù‰πãÊòü
            topStar = new THREE.Group();
            const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: dotTexture, color: 0xffaa00, blending: THREE.AdditiveBlending, depthWrite: false }));
            halo.scale.set(15, 15, 1);
            topStar.add(halo);
            topStar.position.set(0, CONFIG.treeHeight + 1, 0);
            topStar.userData = { halo };
            scene.add(topStar);
        }

        function createPhotoCloud() {
            const geo = new THREE.PlaneGeometry(4, 4.8);
            for(let i=0; i<CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: dummyTexture, side: THREE.DoubleSide, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                
                const t = i/CONFIG.photoCount;
                const y = (1-t) * (CONFIG.treeHeight-5) + 2;
                const r = (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius + 2; 
                const angle = i * 2.5;

                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                // ÁÖßÁâáÁöÑÈì∂Ê≤≥Êï∞ÊçÆ
                const scatterRadius = 40 + Math.random() * 10;
                const scatterAngle = Math.random() * Math.PI * 2;
                const scatterSpeed = (Math.random() - 0.5) * 0.005;

                mesh.position.copy(treePos);
                mesh.lookAt(0, y, 0);
                mesh.userData = { treePos, scatterRadius, scatterAngle, scatterSpeed };
                
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createSnow() {
            const count = 1000;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<count; i++) pos.push((Math.random()-0.5)*100, Math.random()*80, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 0.8, map: dotTexture, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        let animationProgress = { val: 0 }; 

        function switchState(newState) {
            if (state === newState) return;
            state = newState;
            
            if (state === 'ZOOM') {
                gsap.to(treeSystem.material, { opacity: 0.1, duration: 1 }); // Ê†ëÂèòÊöó
                gsap.to(camera.position, { z: 65, duration: 1 });
            } else {
                gsap.to(treeSystem.material, { opacity: 0.9, duration: 1 }); // Ê†ëÊÅ¢Â§ç
                if (zoomedPhoto) gsap.to(zoomedPhoto.scale, { x:1, y:1, z:1, duration: 1 });
                zoomedPhoto = null;
            }

            if (state === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 25, z: 80, duration: 2 });
                gsap.to(animationProgress, { val: 0, duration: 2, ease: "power2.inOut" });
            } else if (state === 'SCATTER') {
                gsap.to(animationProgress, { val: 1, duration: 2.5, ease: "power2.out" }); 
            }
        }

        function zoomToPhoto(mesh) {
            if (zoomedPhoto === mesh) return;
            if (state !== 'ZOOM' && state !== 'SCATTER') switchState('SCATTER');
            
            setTimeout(() => {
                if (zoomedPhoto) gsap.to(zoomedPhoto.scale, { x:1, y:1, z:1, duration: 1 });
                zoomedPhoto = mesh;
                switchState('ZOOM');
                gsap.to(mesh.position, { x:0, y:20, z:50, duration: 1.5 });
                gsap.to(mesh.rotation, { x:0, y:0, z:0, duration: 1.5 });
                gsap.to(mesh.scale, { x:3, y:3, z:3, duration: 1.5 });
            }, state === 'TREE' ? 1000 : 0);
        }

        function handleUpload(e) {
            const files = Array.from(e.target.files);
            let idx = 0;
            files.forEach(file => {
                if (idx >= photoMeshes.length) return;
                new THREE.TextureLoader().load(URL.createObjectURL(file), (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    photoMeshes[idx].material.map = tex;
                    photoMeshes[idx].material.needsUpdate = true;
                    idx++;
                });
            });
        }
        
        // ‰øÆÂ§ç: Â±ïÂºÄÂ∫ïÈÉ®ÂáΩÊï∞ÔºåÈò≤Ê≠¢Â§çÂà∂ÈîôËØØ
        async function setupWebcam() {
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
            video.srcObject = stream;
            return new Promise(r => video.onloadeddata = r);
        }

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
        }
        
        function detectGesture(landmarks) {
            const lm = landmarks[0];
            const palmX = 1-lm[9].x, palmY = lm[9].y;
            const cursor = document.getElementById('hand-cursor');
            cursor.style.display='block'; cursor.style.left=(palmX*100)+'%'; cursor.style.top=(palmY*100)+'%';
            
            const wrist = lm[0];
            const tips = [lm[8],lm[12],lm[16],lm[20]];
            const avgDist = tips.reduce((s,t) => s+Math.hypot(t.x-wrist.x,t.y-wrist.y,t.z-wrist.z),0)/4;
            const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y, lm[4].z-lm[8].z);
            const now = Date.now();
            
            if (now-gestureCooldown > 800) {
                if(avgDist < 0.28) { if(state!=='TREE'){ switchState('TREE'); gestureCooldown=now;} }
                else if(pinchDist < 0.06) {
                     mouse.x=(palmX*2)-1; mouse.y=-(palmY*2)+1;
                     raycaster.setFromCamera(mouse,camera);
                     const intersects=raycaster.intersectObjects(photoMeshes);
                     if(intersects.length>0){ zoomToPhoto(intersects[0].object); gestureCooldown=now; }
                }
                else if(avgDist > 0.45 && state==='TREE'){ switchState('SCATTER'); gestureCooldown=now; }
            }
            if(state==='SCATTER' && avgDist>0.4) gsap.to(scene.rotation, {y: (palmX-0.5)*3, x: (palmY-0.5)*0.5, duration: 1});
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            const video = document.getElementById('webcam');
            if (handLandmarker && video.currentTime > 0) {
                const res = handLandmarker.detectForVideo(video, performance.now());
                if (res.landmarks && res.landmarks.length) detectGesture(res.landmarks);
                else document.getElementById('hand-cursor').style.display = 'none';
            }

            if(state === 'TREE') {
                camera.position.z = 80 + Math.sin(time * 0.2) * 3;
            }

            if (treeSystem) {
                const pos = treeSystem.geometry.attributes.position;
                const scatter = treeSystem.geometry.attributes.scatterData;
                const t = animationProgress.val; 
                
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const idx = i*3;
                    
                    const tx = particleTargetTree[idx], ty = particleTargetTree[idx+1], tz = particleTargetTree[idx+2];
                    
                    // ‰øÆÂ§ç: ÂÆûÊó∂ËÆ°ÁÆóÊóãËΩ¨‰ΩçÁΩÆÔºå‰ΩÜ‰ΩøÁî®Âõ∫ÂÆöÁöÑÈ´òÂ∫¶
                    const radius = scatter.array[idx];
                    scatter.array[idx+1] += scatter.array[idx+2]; // angle += speed
                    const angle = scatter.array[idx+1];
                    const sx = Math.cos(angle) * radius; 
                    const sz = Math.sin(angle) * radius;
                    
                    // ‰øÆÂ§ç: ‰ΩøÁî®È¢ÑÂ≠òÁöÑÂõ∫ÂÆöÈ´òÂ∫¶ÔºåËÄå‰∏çÊòØ Math.random()
                    const sy = particleTargetScatter[idx+1];

                    pos.array[idx]   = tx * (1-t) + sx * t;
                    pos.array[idx+1] = ty * (1-t) + sy * t;
                    pos.array[idx+2] = tz * (1-t) + sz * t;

                    if(state==='TREE') pos.array[idx+1] += Math.sin(time*2 + tx)*0.02; 
                }
                pos.needsUpdate = true;
                
                if(state==='TREE') scene.rotation.y += 0.001;
                else if(state==='SCATTER') scene.rotation.y += 0.0005;
            }
            
            photoMeshes.forEach(m => {
                if (state==='SCATTER' && m !== zoomedPhoto) {
                    m.userData.scatterAngle += m.userData.scatterSpeed;
                    const r = m.userData.scatterRadius;
                    const a = m.userData.scatterAngle;
                    m.position.x = Math.cos(a) * r;
                    m.position.z = Math.sin(a) * r;
                }
            });

            if(topStar) topStar.userData.halo.scale.setScalar(15 + Math.sin(time * 2) * 3);
            
            if(snowSystem) {
                const pos = snowSystem.geometry.attributes.position;
                for(let i=0; i<1000; i++) {
                    pos.array[i*3+1] -= 0.1;
                    if(pos.array[i*3+1] < -10) pos.array[i*3+1] = 60;
                }
                pos.needsUpdate = true;
            }

            composer.render();
        }

        init();
    </script>
</body>
</html>
