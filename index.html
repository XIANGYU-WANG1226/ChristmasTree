<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Golden Noel - The Final Cut</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            touch-action: none;
        }

        #canvas-container {
            width: 100vw; height: 100vh;
            position: absolute; top: 0; left: 0; z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 15px; box-sizing: border-box;
        }

        .header {
            text-align: center; margin-top: 20px;
        }
        
        h1 { 
            margin: 0; font-size: 2.2rem; letter-spacing: 5px; 
            color: #FFD700;
            text-shadow: 0 0 10px #FFD700, 0 0 20px #FF8C00, 0 0 40px #8B0000;
            font-family: "Times New Roman", serif;
            font-weight: 100;
        }
        
        .controls-info {
            background: rgba(10, 5, 0, 0.7);
            backdrop-filter: blur(8px);
            padding: 20px; border-radius: 1px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #dcb; 
            pointer-events: auto;
            max-width: 320px; font-size: 0.85rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        .controls-info h3 { margin: 0 0 10px 0; color: #FFD700; text-transform: uppercase; letter-spacing: 2px;}
        .controls-info ul { padding-left: 18px; margin: 0; line-height: 1.8; }
        .controls-info li b { color: #fff; }

        .btn {
            display: inline-block; margin-top: 15px; width: 100%; box-sizing: border-box;
            background: linear-gradient(180deg, #b8860b, #8B6508);
            border: 1px solid #FFD700; color: #fff;
            padding: 10px 0; text-align: center;
            cursor: pointer; font-weight: bold; pointer-events: auto;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(184, 134, 11, 0.4);
            transition: all 0.3s;
        }
        .btn:active { transform: scale(0.98); }

        /* Loading Screen */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1000, #000000);
            z-index: 100;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #FFD700; text-align: center;
        }
        #start-btn {
            margin-top: 30px; padding: 15px 40px; font-size: 1.2rem;
            display: none; cursor: pointer; background: transparent;
            color: #FFD700; border: 2px solid #FFD700; 
            text-transform: uppercase; letter-spacing: 3px;
            transition: all 0.5s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }
        #start-btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }

        /* Video Feed */
        #webcam {
            position: absolute; bottom: 10px; right: 10px;
            width: 100px; opacity: 0.3; transform: scaleX(-1);
            border: 1px solid #FFD700; z-index: 5;
            transition: opacity 0.3s;
        }
        #webcam:hover { opacity: 1; }

        /* Hand Cursor */
        #hand-cursor {
            position: absolute; width: 20px; height: 20px;
            border: 2px solid #FFD700; transform: translate(-50%, -50%) rotate(45deg);
            box-shadow: 0 0 15px #FFD700, inset 0 0 10px #FFD700;
            z-index: 20; display: none; pointer-events: none;
            transition: all 0.2s;
        }
    </style>
</head>
<body>

    <audio id="bgm" src="music.mp3" loop></audio>

    <div id="loading">
        <div id="loading-text" style="font-size: 2.5rem; letter-spacing: 5px; font-family:serif;">GOLDEN NOEL</div>
        <div id="loading-sub" style="color:#886; margin-top:10px; font-size:0.8rem;">LOADING ASSETS...</div>
        <button id="start-btn">ENTER</button>
    </div>

    <div id="ui-layer">
        <div class="header"><h1>MERRY CHRISTMAS</h1></div>
        <div class="controls-info">
            <h3>Controls</h3>
            <ul>
                <li>‚úä <b>Fist</b> : Assemble</li>
                <li>üñê <b>Open</b> : Explode</li>
                <li>ü§è <b>Pinch</b> : Focus Photo</li>
                <li>üëã <b>Wave</b> : Rotate</li>
            </ul>
            <label class="btn"> UPLOAD PHOTOS <input type="file" id="file-input" multiple accept="image/*" style="display:none"></label>
        </div>
    </div>

    <div id="hand-cursor"></div>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="importmap">
        { "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }}
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        // üì± ÊÄßËÉΩËá™ÈÄÇÂ∫î
        const isMobile = window.innerWidth < 768;
        const CONFIG = {
            colors: { gold: 0xFFAA00, red: 0x8B0000, green: 0x1a2e1a, white: 0xFFFFE0 },
            particleCount: isMobile ? 500 : 850,
            photoCount: isMobile ? 8 : 10,
            treeHeight: 35,
            treeRadius: 14,
            snowCount: isMobile ? 400 : 800
        };

        let scene, camera, renderer, composer;
        let ornaments = [], photoMeshes = [], lightBalls = []; 
        let snowSystem, topStar;
        let dummyTexture;
        let state = 'TREE'; 
        let zoomedPhoto = null;
        let handLandmarker;
        let gestureCooldown = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function init() {
            try {
                const subText = document.getElementById('loading-sub');
                subText.innerText = "POLISHING GOLD...";
                setupScene();
                
                createMaterials();
                createOrnaments();
                createPhotoCloud();
                createSnow(); 
                
                subText.innerText = "CONNECTING VISION...";
                await setupWebcam();
                await setupMediaPipe();

                document.getElementById('loading-text').innerText = "READY";
                subText.style.display = 'none';
                document.getElementById('start-btn').style.display = 'block';

                document.getElementById('start-btn').addEventListener('click', () => {
                    document.getElementById('loading').style.display = 'none';
                    const audio = document.getElementById('bgm');
                    audio.volume = 0.6; audio.play().catch(() => {});
                    animate();
                });

                window.addEventListener('resize', onWindowResize);
                document.getElementById('file-input').addEventListener('change', handleUpload);

            } catch (err) { console.error(err); document.getElementById('loading-sub').innerText = "ERROR: " + err.message; }
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050200, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 70);
            camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            const mainLight = new THREE.PointLight(0xffaa00, 3, 150); mainLight.position.set(20, 30, 40); scene.add(mainLight);
            const rimLight = new THREE.PointLight(0xff0000, 2, 100); rimLight.position.set(-30, 10, 20); scene.add(rimLight);
            const innerLight = new THREE.PointLight(0xffd700, 1, 60); innerLight.position.set(0, 15, 0); scene.add(innerLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; bloomPass.strength = 1.5; bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // ‚úÖ ‰øÆÂ§ç1ÔºöË°•ÂÖ®Èõ™Ëä±ÁîüÊàêÂáΩÊï∞
        function createSnow() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; 
            const ctx = canvas.getContext('2d'); 
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16); 
            grad.addColorStop(0, 'rgba(255, 215, 150, 1.0)'); 
            grad.addColorStop(1, 'rgba(255, 255, 255, 0.0)'); 
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32); 
            const texture = new THREE.CanvasTexture(canvas); 
            
            const geo = new THREE.BufferGeometry(); 
            const positions = [], velocities = []; 
            for(let i=0; i<CONFIG.snowCount; i++) { 
                positions.push((Math.random()-0.5)*150, Math.random()*100, (Math.random()-0.5)*150); 
                velocities.push((Math.random()-0.5)*0.1, Math.random()*0.2+0.05, (Math.random()-0.5)*0.1); 
            } 
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); 
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3)); 
            
            snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({ 
                color: 0xffffff, size: 0.8, map: texture, transparent: true, 
                opacity: 0.8, depthWrite: false, blending: THREE.AdditiveBlending 
            })); 
            scene.add(snowSystem);
        }

        // ‚úÖ ‰øÆÂ§ç2ÔºöË°•ÂÖ®ÊùêË¥®ÁîüÊàêÂáΩÊï∞
        function createMaterials() { 
            const cvs = document.createElement('canvas'); cvs.width = 300; cvs.height = 360; 
            const ctx = cvs.getContext('2d'); 
            ctx.fillStyle = '#111'; ctx.fillRect(0,0,300,360); 
            ctx.lineWidth = 15; ctx.strokeStyle = '#B8860B'; ctx.strokeRect(7,7,286,346); 
            ctx.lineWidth = 2; ctx.strokeStyle = '#FFD700'; ctx.strokeRect(20,20,260,320); 
            ctx.fillStyle = '#FFD700'; ctx.font = '30px Times New Roman'; ctx.textAlign = 'center'; 
            ctx.fillText("MEMORIES", 150, 170); 
            ctx.font = '15px Courier'; ctx.fillStyle = '#886600'; ctx.fillText("MERRY CHRISTMAS", 150, 200); 
            dummyTexture = new THREE.CanvasTexture(cvs); 
        }

        // ‚úÖ ‰øÆÂ§ç3ÔºöË°•ÂÖ®Ë£ÖÈ•∞Áâ©ÈÄªËæë (Á°Æ‰øù mesh Ë¢´ÂàõÂª∫)
        function createOrnaments() {
            const geometries = [
                new THREE.SphereGeometry(0.6, 24, 24), new THREE.BoxGeometry(0.9, 0.9, 0.9),
                new THREE.IcosahedronGeometry(0.7, 0), new THREE.CylinderGeometry(0.1, 0.1, 1.5)
            ];
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.15, emissive: 0x221100 });
            const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, metalness: 0.6, roughness: 0.3 });
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.2, roughness: 0.8 });
            const matLight = new THREE.MeshBasicMaterial({ color: 0xffffaa });

            // ‚≠ê Ê†ëÈ°∂Êòü
            const starGeo = new THREE.OctahedronGeometry(2.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
            topStar = new THREE.Mesh(starGeo, starMat);
            
            const haloCanvas = document.createElement('canvas'); haloCanvas.width = 128; haloCanvas.height = 128;
            const haloCtx = haloCanvas.getContext('2d');
            const haloGrad = haloCtx.createRadialGradient(64, 64, 0, 64, 64, 64);
            haloGrad.addColorStop(0.1, 'rgba(255, 220, 150, 0.8)'); haloGrad.addColorStop(1, 'rgba(255, 165, 0, 0)');
            haloCtx.fillStyle = haloGrad; haloCtx.fillRect(0,0,128,128);
            const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(haloCanvas), blending: THREE.AdditiveBlending, depthWrite: false }));
            halo.scale.set(30, 30, 1);
            topStar.add(halo); 
            topStar.userData.halo = halo;

            topStar.position.set(0, CONFIG.treeHeight + 1, 0);
            topStar.userData.treePos = new THREE.Vector3(0, CONFIG.treeHeight + 1, 0);
            topStar.userData.scatterPos = new THREE.Vector3(0, 50, 0);
            scene.add(topStar);
            ornaments.push(topStar);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                if (Math.random() < 0.15) {
                    mesh = new THREE.Mesh(geometries[0], matLight.clone());
                    mesh.scale.setScalar(0.4);
                    mesh.userData = { isLamp: true, phase: Math.random()*Math.PI, speed: 1+Math.random() };
                    lightBalls.push(mesh);
                } else {
                    // Ë°•ÂÖ®ÔºöÈöèÊú∫ÈÄâÊã©ÂΩ¢Áä∂ÂíåÊùêË¥®
                    const geoIndex = Math.floor(Math.random() * geometries.length);
                    const rand = Math.random();
                    const mat = rand < 0.6 ? matGold : (rand < 0.85 ? matRed : matGreen);
                    mesh = new THREE.Mesh(geometries[geoIndex], mat);
                    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    const s = THREE.MathUtils.randFloat(0.5, 1.2);
                    mesh.scale.set(s,s,s);
                    if(geoIndex === 3) mesh.scale.set(1,1,1);
                }

                // Ê†ëÂàÜÂ∏É
                const hPercent = Math.random();
                const y = Math.pow(hPercent, 0.8) * CONFIG.treeHeight; 
                const maxR = (1 - (y / CONFIG.treeHeight)) * CONFIG.treeRadius;
                const r = Math.sqrt(Math.random()) * maxR; 
                const angle = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                // ÁàÜÁÇ∏ÂàÜÂ∏É (ÁêÉÂ£≥)
                const scatterR = THREE.MathUtils.randFloat(20, 60);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const scatterPos = new THREE.Vector3(
                    scatterR * Math.sin(phi) * Math.cos(theta),
                    scatterR * Math.cos(phi) + 15,
                    scatterR * Math.sin(phi) * Math.sin(theta)
                );

                mesh.position.copy(treePos);
                mesh.userData.treePos = treePos;
                mesh.userData.scatterPos = scatterPos;
                scene.add(mesh);
                ornaments.push(mesh);
            }
        }
        
        // ‚úÖ ‰øÆÂ§ç4ÔºöË°•ÂÖ®ÁÖßÁâá‰∫ëÈÄªËæë
        function createPhotoCloud() {
            const geom = new THREE.PlaneGeometry(3.5, 4.2);
            for (let i = 0; i < CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: dummyTexture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geom, mat);
                
                const t = i / CONFIG.photoCount;
                const y = (1 - t) * (CONFIG.treeHeight - 5) + 3;
                const r = t * (CONFIG.treeRadius + 2) + 1;
                const angle = i * 2.5; 
                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                const scatterR = 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const scatterPos = new THREE.Vector3(
                    scatterR * Math.sin(phi) * Math.cos(theta),
                    scatterR * Math.cos(phi) + 10,
                    scatterR * Math.sin(phi) * Math.sin(theta)
                );

                mesh.position.copy(treePos);
                mesh.lookAt(0, y, 0);
                mesh.userData = { 
                    isPhoto: true, treePos, scatterPos,
                    treeRot: mesh.rotation.clone(),
                    scatterRot: new THREE.Euler(Math.random()*3, Math.random()*3, 0)
                };
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        async function setupWebcam() {
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
            video.srcObject = stream;
            return new Promise(resolve => video.onloadeddata = resolve);
        }

        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
        }
        
        function handleUpload(e) {
            const files = Array.from(e.target.files);
            let idx = 0;
            files.forEach(file => {
                if (idx >= photoMeshes.length) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace;
                        photoMeshes[idx].material.map = tex;
                        photoMeshes[idx].material.needsUpdate = true;
                        idx++;
                    });
                };
                reader.readAsDataURL(file);
            });
        }

        function switchState(newState) {
            if (state === newState) return;
            state = newState;
            if (state === 'ZOOM') gsap.to(scene.fog, { density: 0.04, duration: 1 });
            else gsap.to(scene.fog, { density: 0.015, duration: 1 });

            if (state === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 20, z: 70, duration: 2, ease: "power2.inOut" });
                moveItems(m => m.userData.treePos, m => m.userData.treeRot);
            } else if (state === 'SCATTER') {
                moveItems(m => m.userData.scatterPos, m => m.userData.scatterRot, "elastic.out(1, 0.5)");
            }
        }

        function moveItems(posFn, rotFn, ease = "power2.inOut") {
            ornaments.forEach((m, i) => gsap.to(m.position, { 
                ...posFn(m), duration: 2.5, delay: i * 0.002, ease 
            }));
            photoMeshes.forEach((m, i) => {
                gsap.to(m.position, { ...posFn(m), duration: 2.5, delay: i * 0.05, ease });
                if(rotFn) gsap.to(m.rotation, { x: rotFn(m).x, y: rotFn(m).y, z: rotFn(m).z, duration: 2.5, delay: i * 0.05 });
                gsap.to(m.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            });
        }

        function zoomToPhoto(mesh) {
            if (state === 'ZOOM' && zoomedPhoto === mesh) return;
            switchState('ZOOM'); 
            zoomedPhoto = mesh;
            gsap.to(mesh.position, { x: 0, y: 20, z: 55, duration: 1 });
            gsap.to(mesh.rotation, { x: 0, y: 0, z: 0, duration: 1 });
            gsap.to(mesh.scale, { x: 4, y: 4, z: 4, duration: 1 });
        }

        // ‚úÖ ‰øÆÂ§ç5ÔºöË°•ÂÖ®ÊâãÂäøÊ£ÄÊµã
        function detectGesture(landmarks) {
            const lm = landmarks[0];
            const palmX = 1-lm[9].x, palmY = lm[9].y;
            const cursor = document.getElementById('hand-cursor');
            cursor.style.display='block';
            cursor.style.left=(palmX*100)+'%'; cursor.style.top=(palmY*100)+'%';
            
            const wrist = lm[0];
            const tips = [lm[8],lm[12],lm[16],lm[20]];
            const avgDist = tips.reduce((s,t) => s+Math.hypot(t.x-wrist.x,t.y-wrist.y,t.z-wrist.z),0)/4;
            const pinchDist = Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y,lm[4].z-lm[8].z);
            
            const now=Date.now();
            if (now-gestureCooldown > 600) {
                if(avgDist<0.28){
                    if(state!=='TREE'){switchState('TREE');gestureCooldown=now;}
                    cursor.style.borderColor='#ff3333';
                    cursor.style.transform="translate(-50%, -50%) rotate(45deg) scale(0.8)";
                } 
                else if(pinchDist<0.05){
                    cursor.style.borderColor='#00ff00';
                    cursor.style.transform="translate(-50%, -50%) rotate(0deg) scale(0.5)";
                    mouse.x=(palmX*2)-1; mouse.y=-(palmY*2)+1;
                    raycaster.setFromCamera(mouse,camera);
                    const intersects=raycaster.intersectObjects(photoMeshes);
                    if(intersects.length>0){zoomToPhoto(intersects[0].object);gestureCooldown=now;}
                } 
                else if(avgDist>0.45&&state==='TREE'){
                    switchState('SCATTER');gestureCooldown=now;
                    cursor.style.borderColor='#FFD700';
                    cursor.style.transform="translate(-50%,-50%) rotate(45deg) scale(1.2)";
                }
            }
            if(state==='SCATTER'&&avgDist>0.4){
                gsap.to(scene.rotation,{y:(palmX-0.5)*2.5,x:(palmY-0.5)*0.5,duration:1});
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            const video = document.getElementById('webcam');
            if (handLandmarker && video.currentTime > 0) {
                const res = handLandmarker.detectForVideo(video, performance.now());
                if (res.landmarks && res.landmarks.length) detectGesture(res.landmarks);
                else document.getElementById('hand-cursor').style.display = 'none';
            }

            if (state === 'TREE') {
                scene.rotation.y += 0.0015;
                scene.position.y = Math.sin(time * 0.5) * 0.3; // ÂëºÂê∏ÊµÆÂä®
                if(topStar) {
                    topStar.rotation.y -= 0.01;
                    topStar.userData.halo.scale.setScalar(30 + Math.sin(time * 2) * 5);
                }
            } else {
                gsap.to(scene.position, { y: 0, duration: 1 });
            }

            lightBalls.forEach(m => {
                const blink = Math.sin(time * m.userData.speed + m.userData.phase);
                m.material.color.setHex(0xffffaa).multiplyScalar(0.8 + blink * 0.5);
            });

            // ‚úÖ ‰øÆÂ§ç6ÔºöÈõ™Ëä±Êõ¥Êñ∞ÈÄªËæë
            if (snowSystem) {
                const pos = snowSystem.geometry.attributes.position;
                const vel = snowSystem.geometry.attributes.velocity;
                for(let i=0; i<CONFIG.snowCount; i++) {
                    const idx = i*3;
                    // ‰∏ãËêΩ
                    pos.array[idx+1] -= vel.array[idx+1];
                    // È£òÂä®
                    pos.array[idx] += Math.sin(time + pos.array[idx+1]*0.1) * vel.array[idx]; 
                    // Âæ™ÁéØ
                    if (pos.array[idx+1] < -10) pos.array[idx+1] = 60; 
                }
                pos.needsUpdate = true;
            }
            
            composer.render();
        }

        init();
    </script>
</body>
</html>
