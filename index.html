<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Gold Christmas (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; user-select: none; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .header { text-align: center; margin-top: 10px; }
        /* æ ‡é¢˜æ›´äº® */
        h1 { margin: 0; font-size: 2.5rem; letter-spacing: 5px; color: #FFF; text-shadow: 0 0 10px #FFD700, 0 0 30px #FFA500; font-weight: 100; }
        .controls-info { background: rgba(30, 20, 0, 0.7); backdrop-filter: blur(10px); padding: 20px; border: 1px solid rgba(255, 215, 0, 0.5); color: #FFD700; pointer-events: auto; max-width: 320px; font-size: 0.9rem; box-shadow: 0 10px 40px rgba(0,0,0,0.9); }
        .controls-info h3 { margin: 0 0 15px 0; border-bottom: 1px solid #FFD700; padding-bottom: 5px; letter-spacing: 2px;}
        .btn { display: inline-block; margin-top: 15px; width: 100%; box-sizing: border-box; background: linear-gradient(45deg, #FFD700, #FF8C00); border: 1px solid #FFF; color: #000; padding: 12px 0; text-align: center; cursor: pointer; font-weight: bold; pointer-events: auto; text-transform: uppercase; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); transition: 0.3s;}
        .btn:hover { background: #FFF; box-shadow: 0 0 40px #FFD700; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, #221100, #000000); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #FFD700; transition: opacity 0.5s; }
        #loading-text { font-size: 3rem; font-family:serif; text-shadow:0 0 30px #FFD700; margin-bottom: 20px; text-align: center; }
        #loading-sub { color:#aa8800; letter-spacing: 2px; text-align: center; padding: 0 20px; font-size: 0.9rem; }
        #error-log { color: #ff4444; font-size: 0.8rem; margin-top: 30px; max-width: 90%; text-align: center; display: none; border: 1px solid #800; padding: 15px; background: rgba(0,0,0,0.9); border-radius: 8px; }
        #start-btn { margin-top: 30px; padding: 15px 50px; font-size: 1.5rem; display: none; cursor: pointer; background: #FFD700; color: #000; border: 2px solid #FFF; letter-spacing: 5px; transition: 0.5s; font-weight: bold; box-shadow: 0 0 30px #FFD700; border-radius: 5px; }
        #start-btn:hover { background: #FFF; box-shadow: 0 0 60px #FFD700; transform: scale(1.05); }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0.3; transform: scaleX(-1); border: 1px solid #FFD700; z-index: 5; }
        #hand-cursor { position: absolute; width: 30px; height: 30px; border: 2px solid #FFD700; border-radius: 50%; box-shadow: 0 0 20px #FFD700; z-index: 20; display: none; pointer-events: none; transition: 0.1s; }
    </style>
    <script>
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('error-log');
            if(el) { el.style.display = 'block'; el.innerHTML = "âš ï¸ ç¨‹åºé‡åˆ°é—®é¢˜:<br>" + msg; }
        };
    </script>
</head>
<body>
    <audio id="bgm" src="music.mp3" loop></audio>
    <div id="loading">
        <div id="loading-text">NEON GOLD</div>
        <div id="loading-sub">CONNECTING...</div>
        <div id="error-log"></div>
        <button id="start-btn">OPEN GIFT</button>
    </div>
    <div id="ui-layer">
        <div class="header"><h1>MERRY CHRISTMAS</h1></div>
        <div class="controls-info">
            <h3>MAGIC CONTROLS</h3>
            <ul><li>âœŠ <b>Fist</b> : Golden Tree</li><li>ğŸ– <b>Open</b> : Treasure Burst</li><li>ğŸ¤ <b>Pinch</b> : Focus Memory</li><li>ğŸ‘‹ <b>Wave</b> : Rotate View</li></ul>
            <label class="btn"> ADD PHOTOS <input type="file" id="file-input" multiple accept="image/*" style="display:none"></label>
        </div>
    </div>
    <div id="hand-cursor"></div>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/+esm"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        const sub = document.getElementById('loading-sub');
        if(sub) sub.innerText = "LOADING ENGINE...";

        const isMobile = window.innerWidth < 768;
        const CONFIG = {
            objectCount: isMobile ? 700 : 1400, // ç¨å¾®å‡å°‘ä¸€ç‚¹ç‚¹æ•°é‡ä»¥æ¢å–å…‰å½±æ€§èƒ½
            photoCount: 12,
            treeHeight: 35,
            treeRadius: 14,
            colors: { 
                gold: 0xFFD700, 
                red: 0xFF0033, 
                green: 0x008844 
            }
        };

        let scene, camera, renderer, composer;
        let ornaments = [], photoMeshes = [], activeLights = [];
        let snowSystem, topStar;
        let dummyTexture;
        let state = 'TREE'; 
        let zoomedPhoto = null;
        let handLandmarker;
        let gestureCooldown = 0;
        let isAnimating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        setTimeout(() => {
            if(sub && sub.style.display !== 'none' && !document.getElementById('error-log').style.display) {
                sub.innerHTML = "LOADING RESOURCES...<br>(Using jsDelivr)";
            }
        }, 8000);

        async function init() {
            try {
                sub.innerText = "LIGHTING UP...";
                setupScene();
                createDummyTexture();
                createRichOrnaments(); 
                createPhotoCloud();
                createSoftSnow();
                
                sub.innerText = "LOADING AI...";
                try { await Promise.all([setupWebcam(), setupMediaPipe()]); } 
                catch(e) { console.warn("AI Init failed"); }

                sub.style.display = 'none';
                document.getElementById('loading-text').innerText = "READY";
                const btn = document.getElementById('start-btn');
                btn.style.display = 'block';
                
                btn.addEventListener('click', () => {
                    document.getElementById('loading').style.opacity = 0;
                    setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 500);
                    const bgm = document.getElementById('bgm');
                    bgm.volume = 0.6; bgm.play().catch(()=>{});
                    if(!isAnimating) { isAnimating = true; animate(); }
                });

                window.addEventListener('resize', onWindowResize);
                document.getElementById('file-input').addEventListener('change', handleUpload);

            } catch (e) { throw e; }
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 70); camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // ğŸ’¡ å…³é”®ä¿®æ”¹ï¼šä½¿ç”¨ Reinhard æ˜ å°„é˜²æ­¢è¿‡æ›ï¼Œä½†å¢åŠ æ›å…‰åº¦
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.5; 
            container.appendChild(renderer.domElement);

            // ğŸ’¡ å…‰ç…§ç³»ç»Ÿï¼šé«˜å¯¹æ¯”åº¦é…ç½®
            const ambient = new THREE.AmbientLight(0xffffff, 0.4); 
            scene.add(ambient);

            // ä¸»å…‰æºï¼šå¼ºåŠ›é‡‘å…‰
            const mainLight = new THREE.PointLight(0xffaa00, 3, 100);
            mainLight.position.set(20, 30, 40);
            scene.add(mainLight);

            // è¡¥å…‰ï¼šè®©æš—éƒ¨ä¹Ÿæœ‰é¢œè‰²
            const fillLight = new THREE.PointLight(0xff8800, 2, 80);
            fillLight.position.set(-20, 10, 40);
            scene.add(fillLight);

            // æ ‘å¿ƒï¼šé«˜äº®æ ¸å¿ƒ
            const coreLight = new THREE.PointLight(0xffd700, 2, 60);
            coreLight.position.set(0, 15, 0);
            scene.add(coreLight);

            // âœ¨ è¾‰å…‰è®¾ç½®ï¼šåªæ™•æŸ“é«˜å…‰
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.4; // â¬†ï¸ æé«˜é˜ˆå€¼ï¼šé˜²æ­¢æ•´ä¸ªçƒéƒ½å‘å…‰ï¼Œåªæœ‰åå…‰ç‚¹å‘å…‰
            bloomPass.strength = 1.0;  // é€‚åº¦å…‰æ™•
            bloomPass.radius = 0.6;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createDummyTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 512; cvs.height = 600;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#fff'; ctx.fillRect(0,0,512,600);
            ctx.fillStyle = '#000'; ctx.fillRect(30,30,452,452);
            ctx.font = '40px Times New Roman'; ctx.fillStyle = '#333'; ctx.textAlign = 'center';
            ctx.fillText("WINTER MEMORY", 256, 550);
            dummyTexture = new THREE.CanvasTexture(cvs);
            dummyTexture.colorSpace = THREE.SRGBColorSpace;
        }

        function createRichOrnaments() {
            const geoSphere = new THREE.SphereGeometry(1, 24, 24);
            const geoBox = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const geoGem = new THREE.OctahedronGeometry(1.2, 0);

            // ğŸ¨ æè´¨è°ƒä¼˜ï¼šéœ“è™¹æ„Ÿ (Neon Feel)
            
            // äº®é‡‘ï¼šå‡å°‘é•œé¢åå°„ï¼Œå¢åŠ è‡ªå‘å…‰
            const matGold = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00, 
                metalness: 0.3,   // â¬‡ï¸ é™ä½é‡‘å±åº¦ï¼Œé˜²æ­¢å˜é»‘
                roughness: 0.3, 
                emissive: 0xff8800, // â¬†ï¸ äº®æ©™è‰²è‡ªå‘å…‰
                emissiveIntensity: 0.6 // â¬†ï¸ å¼ºåº¦æé«˜ï¼Œä¿è¯çœ‹èµ·æ¥æ˜¯äº®çš„
            });
            
            // äº®çº¢
            const matRed = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                metalness: 0.2, 
                roughness: 0.3,
                emissive: 0xaa0000,
                emissiveIntensity: 0.4
            });
            
            // äº®ç»¿
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, 
                metalness: 0.2, 
                roughness: 0.3,
                emissive: 0x004400,
                emissiveIntensity: 0.3
            });

            // çº¯ç™½ç¯çƒ (Cloneç”¨)
            const matLight = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for (let i = 0; i < CONFIG.objectCount; i++) {
                let mesh;
                const rand = Math.random();
                
                // ç¯çƒ
                if (rand < 0.15) {
                    mesh = new THREE.Mesh(geoSphere, matLight.clone());
                    mesh.scale.setScalar(0.4); 
                    activeLights.push({ mesh, speed: Math.random()*2+1, phase: Math.random()*Math.PI });
                } else {
                    let geo, mat;
                    const shapeR = Math.random();
                    if (shapeR < 0.6) geo = geoSphere; 
                    else if (shapeR < 0.85) geo = geoBox; 
                    else geo = geoGem; 

                    const colorR = Math.random();
                    if (colorR < 0.65) mat = matGold; 
                    else if (colorR < 0.85) mat = matRed;
                    else mat = matGreen;

                    mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    const s = Math.random() * 0.5 + 0.3; 
                    mesh.scale.set(s,s,s);
                }

                // æ ‘å½¢åˆ†å¸ƒï¼šä½“ç§¯å¡«å……
                const hPercent = Math.random(); 
                const y = Math.pow(hPercent, 0.9) * CONFIG.treeHeight;
                const maxR = (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius;
                const r = Math.sqrt(Math.random()) * maxR; 
                const angle = Math.random() * Math.PI * 2;
                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                const scatterDir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                const scatterDist = 20 + Math.random() * 40;
                const scatterPos = scatterDir.multiplyScalar(scatterDist).add(new THREE.Vector3(0, 20, 0));

                mesh.position.copy(treePos);
                mesh.userData = { treePos, scatterPos, rotSpeed: {x: Math.random()*0.02, y: Math.random()*0.02} };
                scene.add(mesh);
                ornaments.push(mesh);
            }

            // æ ‘é¡¶æ˜Ÿï¼šæ”¹ä¸ºçº¯å‘å…‰ä½“
            const starGeo = new THREE.OctahedronGeometry(2.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 }); 
            topStar = new THREE.Mesh(starGeo, starMat);
            topStar.position.set(0, CONFIG.treeHeight + 1.5, 0);
            
            // å…‰æ™•
            const haloCvs = document.createElement('canvas'); haloCvs.width=64; haloCvs.height=64;
            const hCtx = haloCvs.getContext('2d');
            const grd = hCtx.createRadialGradient(32,32,0,32,32,32);
            grd.addColorStop(0, 'rgba(255,180,50,0.8)'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            hCtx.fillStyle = grd; hCtx.fillRect(0,0,64,64);
            const haloTex = new THREE.CanvasTexture(haloCvs);
            const spriteMat = new THREE.SpriteMaterial({ map: haloTex, blending: THREE.AdditiveBlending });
            const halo = new THREE.Sprite(spriteMat);
            halo.scale.set(20, 20, 1);
            topStar.add(halo);
            topStar.userData = { halo };
            scene.add(topStar);
        }

        function createPhotoCloud() {
            const geo = new THREE.PlaneGeometry(4, 4.8);
            for (let i = 0; i < CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: dummyTexture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const t = i / CONFIG.photoCount;
                const y = (1-t) * (CONFIG.treeHeight-5) + 3;
                const r = (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius + 2.5; 
                const angle = i * 2.0;
                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*80, Math.random()*40+10, (Math.random()-0.5)*80);
                mesh.position.copy(treePos);
                mesh.lookAt(0, y, 0);
                mesh.userData = { treePos, scatterPos };
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createSoftSnow() {
            const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,0.9)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(canvas);
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const vel = [];
            for(let i=0; i<1000; i++) {
                pos.push((Math.random()-0.5)*120, Math.random()*80, (Math.random()-0.5)*120);
                vel.push((Math.random()-0.5)*0.05, Math.random()*0.1+0.02, (Math.random()-0.5)*0.05);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(vel, 3));
            const mat = new THREE.PointsMaterial({ size: 0.7, map: tex, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, depthWrite: false });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function switchState(newState) {
            if (state === newState) return;
            state = newState;
            if (state === 'TREE') gsap.to(camera.position, { x: 0, y: 20, z: 70, duration: 2, ease: "power2.inOut" });
            const targetProp = state === 'TREE' ? 'treePos' : 'scatterPos';
            const ease = state === 'TREE' ? "power2.inOut" : "back.out(1.2)";
            ornaments.forEach((m, i) => {
                const target = m.userData[targetProp];
                gsap.to(m.position, { x: target.x, y: target.y, z: target.z, duration: 1.5, delay: i * 0.001, ease: ease });
                if(state === 'SCATTER') gsap.to(m.rotation, { x: Math.random()*Math.PI, y: Math.random()*Math.PI, duration: 1.5 });
            });
            photoMeshes.forEach(m => {
                const target = m.userData[targetProp];
                gsap.to(m.position, { x: target.x, y: target.y, z: target.z, duration: 1.5, ease: ease });
                if(state === 'ZOOM' && zoomedPhoto === m) return;
                gsap.to(m.scale, { x:1, y:1, z:1, duration: 0.5 });
            });
        }

        function zoomToPhoto(mesh) {
            if(zoomedPhoto === mesh) return;
            switchState('ZOOM');
            zoomedPhoto = mesh;
            gsap.to(mesh.position, { x:0, y:20, z:55, duration: 1 });
            gsap.to(mesh.rotation, { x:0, y:0, z:0, duration: 1 });
            gsap.to(mesh.scale, { x:3, y:3, z:3, duration: 1 });
        }

        function handleUpload(e) {
            const files = Array.from(e.target.files);
            let idx = 0;
            files.forEach(file => {
                if(idx >= photoMeshes.length) return;
                new THREE.TextureLoader().load(URL.createObjectURL(file), (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    photoMeshes[idx].material.map = tex;
                    photoMeshes[idx].material.needsUpdate = true;
                    idx++;
                });
            });
        }

        async function setupWebcam() {
            try {
                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                video.srcObject = stream;
                return new Promise(r => video.onloadeddata = r);
            } catch(e) { console.warn("Camera failed", e); }
        }
        async function setupMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
            } catch(e) { throw new Error("AI Load Failed"); }
        }
        function detectGesture(landmarks) {
            const lm = landmarks[0];
            const palmX = 1-lm[9].x, palmY = lm[9].y;
            const cursor = document.getElementById('hand-cursor');
            cursor.style.display='block'; cursor.style.left=(palmX*100)+'%'; cursor.style.top=(palmY*100)+'%';
            const wrist = lm[0];
            const tips = [lm[8],lm[12],lm[16],lm[20]];
            const avgDist = tips.reduce((s,t) => s+Math.hypot(t.x-wrist.x,t.y-wrist.y,t.z-wrist.z),0)/4;
            const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y, lm[4].z-lm[8].z);
            const now = Date.now();
            if (now-gestureCooldown > 800) {
                if(avgDist < 0.28) { if(state!=='TREE'){ switchState('TREE'); gestureCooldown=now;} cursor.style.borderColor='red'; }
                else if(pinchDist < 0.08) { 
                    mouse.x=(palmX*2)-1; mouse.y=-(palmY*2)+1;
                    raycaster.setFromCamera(mouse,camera);
                    const intersects=raycaster.intersectObjects(photoMeshes);
                    if(intersects.length>0){ zoomToPhoto(intersects[0].object); gestureCooldown=now; }
                    cursor.style.borderColor='green';
                }
                else if(avgDist > 0.45 && state==='TREE'){ switchState('SCATTER'); gestureCooldown=now; cursor.style.borderColor='gold'; }
            }
            if(state==='SCATTER' && avgDist>0.4) { gsap.to(scene.rotation, {y: (palmX-0.5)*3, x: (palmY-0.5)*0.5, duration: 1}); }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            const video = document.getElementById('webcam');
            if (handLandmarker && video.currentTime > 0) {
                const res = handLandmarker.detectForVideo(video, performance.now());
                if (res.landmarks && res.landmarks.length) detectGesture(res.landmarks);
                else document.getElementById('hand-cursor').style.display = 'none';
            }

            if(state === 'TREE') { scene.rotation.y += 0.002; scene.position.y = Math.sin(time*0.5)*0.5; }
            activeLights.forEach(l => {
                const i = 0.5 + Math.sin(time * l.speed + l.phase) * 0.5;
                l.mesh.material.color.setHSL(0.12, 0.8, 0.4 + i*0.4); 
            });
            if(state === 'SCATTER') { ornaments.forEach(m => { m.rotation.x += m.userData.rotSpeed.x; m.rotation.y += m.userData.rotSpeed.y; }); }
            if(snowSystem) {
                const pos = snowSystem.geometry.attributes.position;
                const vel = snowSystem.geometry.attributes.velocity;
                for(let i=0; i<800; i++) {
                    const idx = i*3;
                    pos.array[idx+1] -= vel.array[idx+1]; pos.array[idx] += Math.sin(time + pos.array[idx+1]*0.1) * vel.array[idx];
                    if(pos.array[idx+1] < -50) pos.array[idx+1] = 60; // ä¿®å¤ï¼šé˜²æ­¢é›ªèŠ±çªç„¶æ¶ˆå¤±
                }
                pos.needsUpdate = true;
            }
            if(topStar) topStar.userData.halo.scale.setScalar(20 + Math.sin(time*2)*2);
            composer.render();
        }

        init();
    </script>
</body>
</html>
