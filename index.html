<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Luxury Golden Christmas (Bright Version)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; user-select: none; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .header { text-align: center; margin-top: 10px; }
        h1 { margin: 0; font-size: 2.5rem; letter-spacing: 5px; color: #FFD700; text-shadow: 0 0 20px #FFAA00, 0 0 40px #FF0000; font-weight: 100; }
        .controls-info { background: rgba(50, 40, 0, 0.6); backdrop-filter: blur(10px); padding: 20px; border: 1px solid rgba(255, 215, 0, 0.6); color: #FFD700; pointer-events: auto; max-width: 320px; font-size: 0.9rem; box-shadow: 0 10px 40px rgba(0,0,0,0.9); }
        .controls-info h3 { margin: 0 0 15px 0; border-bottom: 1px solid #FFD700; padding-bottom: 5px; letter-spacing: 2px;}
        .btn { display: inline-block; margin-top: 15px; width: 100%; box-sizing: border-box; background: linear-gradient(45deg, #FFD700, #FFA500); border: 1px solid #FFF; color: #000; padding: 12px 0; text-align: center; cursor: pointer; font-weight: bold; pointer-events: auto; text-transform: uppercase; box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); transition: 0.3s;}
        .btn:hover { background: #FFF; box-shadow: 0 0 40px #FFD700; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, #332200, #000000); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #FFD700; }
        #start-btn { margin-top: 30px; padding: 15px 50px; font-size: 1.5rem; display: none; cursor: pointer; background: #FFD700; color: #000; border: 2px solid #FFF; letter-spacing: 5px; transition: 0.5s; font-weight: bold; box-shadow: 0 0 30px #FFD700;}
        #start-btn:hover { background: #FFF; box-shadow: 0 0 60px #FFD700; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0.3; transform: scaleX(-1); border: 1px solid #FFD700; z-index: 5; }
        #hand-cursor { position: absolute; width: 30px; height: 30px; border: 2px solid #FFD700; border-radius: 50%; box-shadow: 0 0 20px #FFD700; z-index: 20; display: none; pointer-events: none; transition: 0.1s; }
    </style>
</head>
<body>
    <audio id="bgm" src="music.mp3" loop></audio>
    <div id="loading">
        <div id="loading-text" style="font-size: 3rem; font-family:serif; text-shadow:0 0 30px #FFD700;">GOLDEN LUXURY</div>
        <div id="loading-sub" style="color:#aa8800; margin-top:10px; letter-spacing: 2px;">PREPARING GIFTS...</div>
        <button id="start-btn">OPEN GIFT</button>
    </div>
    <div id="ui-layer">
        <div class="header"><h1>MERRY CHRISTMAS</h1></div>
        <div class="controls-info">
            <h3>MAGIC CONTROLS</h3>
            <ul><li>âœŠ <b>Fist</b> : Golden Tree</li><li>ğŸ– <b>Open</b> : Treasure Burst</li><li>ğŸ¤ <b>Pinch</b> : Focus Memory</li><li>ğŸ‘‹ <b>Wave</b> : Rotate View</li></ul>
            <label class="btn"> ADD PHOTOS <input type="file" id="file-input" multiple accept="image/*" style="display:none"></label>
        </div>
    </div>
    <div id="hand-cursor"></div>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/", "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm", "gsap": "https://unpkg.com/gsap@3.12.5/index.js" } }</script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        const isMobile = window.innerWidth < 768;
        const CONFIG = {
            objectCount: isMobile ? 600 : 1300, 
            photoCount: 12,
            treeHeight: 35,
            treeRadius: 14,
            scatterRadius: 60,
            colors: { gold: 0xFFD700, red: 0xDC143C, green: 0x228B22 }
        };

        let scene, camera, renderer, composer;
        let ornaments = [], photoMeshes = [], activeLights = [];
        let snowSystem, topStar;
        let dummyTexture;
        let state = 'TREE'; 
        let zoomedPhoto = null;
        let handLandmarker;
        let gestureCooldown = 0;
        let isAnimating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        async function init() {
            try {
                const sub = document.getElementById('loading-sub');
                sub.innerText = "POLISHING GOLD...";
                setupScene();
                
                createDummyTexture();
                createRichOrnaments(); 
                createPhotoCloud();
                createSoftSnow();
                
                sub.innerText = "STARTING VISION AI...";
                await setupWebcam();
                await setupMediaPipe();

                sub.style.display = 'none';
                document.getElementById('loading-text').innerText = "READY";
                const btn = document.getElementById('start-btn');
                btn.style.display = 'block';
                
                btn.addEventListener('click', () => {
                    document.getElementById('loading').style.display = 'none';
                    const bgm = document.getElementById('bgm');
                    bgm.volume = 0.6; bgm.play().catch(()=>{});
                    if(!isAnimating) { isAnimating = true; animate(); }
                });

                window.addEventListener('resize', onWindowResize);
                document.getElementById('file-input').addEventListener('change', handleUpload);

            } catch (e) { console.error(e); alert("Error: " + e.message); }
        }

        function setupScene() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // é›¾æ°”è°ƒæ·¡ï¼Œä¸è¦é®ä½é‡‘å…‰
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 70); 
            camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3; // æ›å…‰æ‹‰é«˜
            container.appendChild(renderer.domElement);

            // ğŸ’¡ æš´åŠ›è¡¥å…‰ç³»ç»Ÿ (è®©é‡‘è‰²äº®èµ·æ¥çš„å…³é”®)
            // 1. å…¨å±€ç¯å¢ƒå…‰ (å¡«è¡¥é»‘è‰²é˜´å½±)
            const ambient = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambient);

            // 2. åŠçƒå…‰ (æ¨¡æ‹Ÿå¤©å…‰åœ°å…‰ï¼Œé˜²æ­¢æ­»é»‘)
            const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x080820, 1);
            scene.add(hemiLight);
            
            // 3. å¼ºåŠ›ä¸»å…‰æº
            const mainLight = new THREE.PointLight(0xffaa00, 4, 150);
            mainLight.position.set(20, 30, 40);
            scene.add(mainLight);
            
            // 4. ä¾§é¢è¡¥å…‰
            const rimLight = new THREE.PointLight(0xff0000, 3, 80);
            rimLight.position.set(-30, 10, 20);
            scene.add(rimLight);
            
            // 5. æ ‘å¿ƒé«˜äº®
            const coreLight = new THREE.PointLight(0xffd700, 2, 60);
            coreLight.position.set(0, 15, 0);
            scene.add(coreLight);

            // âœ¨ è¾‰å…‰ç‰¹æ•ˆè°ƒå¼º
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; // é˜ˆå€¼æä½ï¼Œè®©æ‰€æœ‰ä¸œè¥¿éƒ½å‘å…‰
            bloomPass.strength = 1.6;  // å¼ºåº¦æ‹‰æ»¡
            bloomPass.radius = 0.6;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createDummyTexture() {
            const cvs = document.createElement('canvas'); cvs.width = 512; cvs.height = 600;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0,0,512,600);
            ctx.fillStyle = '#000'; ctx.fillRect(30,30,452,452);
            ctx.font = '40px Courier'; ctx.fillStyle = '#333'; ctx.textAlign = 'center';
            ctx.fillText("WINTER MEMORY", 256, 550);
            dummyTexture = new THREE.CanvasTexture(cvs);
            dummyTexture.colorSpace = THREE.SRGBColorSpace;
        }

        function createRichOrnaments() {
            const geoSphere = new THREE.SphereGeometry(1, 24, 24);
            const geoBox = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const geoGem = new THREE.OctahedronGeometry(1.2, 0);

            // ğŸ¨ æè´¨å¤§æ”¹ç‰ˆï¼šè‡ªå‘å…‰ (Emissive) æ˜¯å…³é”®
            
            // äº®é‡‘ï¼šé™ä½é‡‘å±åº¦(0.5)ï¼Œæ‹‰é«˜è‡ªå‘å…‰
            const matGold = new THREE.MeshStandardMaterial({ 
                color: 0xffcc00, 
                metalness: 0.4,   // å…³é”®ï¼šä¸è¦å…¨é‡‘å±ï¼Œå¦åˆ™æ²¡åå°„å°±æ˜¯é»‘çš„
                roughness: 0.2, 
                emissive: 0xffaa00, // å…³é”®ï¼šè‡ªå·±å‘å…‰ï¼
                emissiveIntensity: 0.6
            });
            
            // äº®çº¢
            const matRed = new THREE.MeshStandardMaterial({ 
                color: 0xff0033, 
                metalness: 0.3, 
                roughness: 0.2,
                emissive: 0xaa0000,
                emissiveIntensity: 0.4
            });
            
            // äº®ç»¿
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: 0x00aa44, 
                metalness: 0.2, 
                roughness: 0.2,
                emissive: 0x004400,
                emissiveIntensity: 0.3
            });

            // çº¯ç™½ç¯çƒ
            const matLight = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for (let i = 0; i < CONFIG.objectCount; i++) {
                let mesh;
                const rand = Math.random();
                
                // å¢åŠ ç¯çƒæ¯”ä¾‹åˆ° 20%
                if (rand < 0.2) {
                    mesh = new THREE.Mesh(geoSphere, matLight);
                    mesh.scale.setScalar(0.5); // ç¯çƒç¨å¾®å¤§ä¸€ç‚¹
                    activeLights.push({ mesh, speed: Math.random()*3+2, phase: Math.random()*Math.PI });
                } else {
                    let geo, mat;
                    const shapeR = Math.random();
                    if (shapeR < 0.6) geo = geoSphere; 
                    else if (shapeR < 0.85) geo = geoBox; 
                    else geo = geoGem; 

                    const colorR = Math.random();
                    if (colorR < 0.65) mat = matGold; // å¢åŠ é‡‘è‰²æ¯”ä¾‹
                    else if (colorR < 0.85) mat = matRed;
                    else mat = matGreen;

                    mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    const s = Math.random() * 0.5 + 0.4; // æ•´ä½“æ”¾å¤§ä¸€ç‚¹
                    mesh.scale.set(s,s,s);
                }

                // æ ‘å½¢åˆ†å¸ƒ
                const hPercent = Math.random(); 
                const y = Math.pow(hPercent, 0.8) * CONFIG.treeHeight;
                const maxR = (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius;
                const r = Math.sqrt(Math.random()) * maxR; 
                const angle = Math.random() * Math.PI * 2;
                
                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                // çˆ†ç‚¸æ‰©æ•£
                const scatterDir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                const scatterDist = 20 + Math.random() * 40;
                const scatterPos = scatterDir.multiplyScalar(scatterDist).add(new THREE.Vector3(0, 20, 0));

                mesh.position.copy(treePos);
                mesh.userData = { treePos, scatterPos, 
                    rotSpeed: {x: Math.random()*0.02, y: Math.random()*0.02} 
                };
                
                scene.add(mesh);
                ornaments.push(mesh);
            }

            // æ ‘é¡¶å·¨æ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(3.0, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // çº¯äº®é»„
            topStar = new THREE.Mesh(starGeo, starMat);
            topStar.position.set(0, CONFIG.treeHeight + 2, 0);
            
            // æ˜Ÿæ˜Ÿå…‰æ™•
            const haloCvs = document.createElement('canvas'); haloCvs.width=64; haloCvs.height=64;
            const hCtx = haloCvs.getContext('2d');
            const grd = hCtx.createRadialGradient(32,32,0,32,32,32);
            grd.addColorStop(0, 'rgba(255,200,50,1)'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            hCtx.fillStyle = grd; hCtx.fillRect(0,0,64,64);
            const haloTex = new THREE.CanvasTexture(haloCvs);

            const spriteMat = new THREE.SpriteMaterial({ map: haloTex, blending: THREE.AdditiveBlending });
            const halo = new THREE.Sprite(spriteMat);
            halo.scale.set(25, 25, 1);
            topStar.add(halo);
            topStar.userData = { halo };
            scene.add(topStar);
        }

        function createPhotoCloud() {
            const geo = new THREE.PlaneGeometry(4, 4.8);
            for (let i = 0; i < CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: dummyTexture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                
                const t = i / CONFIG.photoCount;
                const y = (1-t) * (CONFIG.treeHeight-5) + 3;
                const r = (1 - y/CONFIG.treeHeight) * CONFIG.treeRadius + 2.5; 
                const angle = i * 2.0;

                const treePos = new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*80, Math.random()*40+10, (Math.random()-0.5)*80);

                mesh.position.copy(treePos);
                mesh.lookAt(0, y, 0);
                mesh.userData = { treePos, scatterPos };
                
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createSoftSnow() {
            const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(canvas);

            const geo = new THREE.BufferGeometry();
            const pos = [];
            const vel = [];
            for(let i=0; i<800; i++) {
                pos.push((Math.random()-0.5)*100, Math.random()*60, (Math.random()-0.5)*100);
                vel.push((Math.random()-0.5)*0.05, Math.random()*0.1+0.02, (Math.random()-0.5)*0.05);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(vel, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 0.8, map: tex, transparent: true, opacity: 0.8, 
                blending: THREE.AdditiveBlending, depthWrite: false
            });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function switchState(newState) {
            if (state === newState) return;
            state = newState;

            if (state === 'TREE') {
                gsap.to(camera.position, { x: 0, y: 20, z: 70, duration: 2, ease: "power2.inOut" });
            }

            const targetProp = state === 'TREE' ? 'treePos' : 'scatterPos';
            const ease = state === 'TREE' ? "power2.inOut" : "back.out(1.2)";
            
            ornaments.forEach((m, i) => {
                const target = m.userData[targetProp];
                gsap.to(m.position, { 
                    x: target.x, y: target.y, z: target.z, 
                    duration: 1.5, 
                    delay: i * 0.001, 
                    ease: ease 
                });
                if(state === 'SCATTER') {
                    gsap.to(m.rotation, { x: Math.random()*Math.PI, y: Math.random()*Math.PI, duration: 1.5 });
                }
            });

            photoMeshes.forEach(m => {
                const target = m.userData[targetProp];
                gsap.to(m.position, { x: target.x, y: target.y, z: target.z, duration: 1.5, ease: ease });
                if(state === 'ZOOM' && zoomedPhoto === m) return;
                gsap.to(m.scale, { x:1, y:1, z:1, duration: 0.5 });
            });
        }

        function zoomToPhoto(mesh) {
            if(zoomedPhoto === mesh) return;
            switchState('ZOOM');
            zoomedPhoto = mesh;
            gsap.to(mesh.position, { x:0, y:20, z:55, duration: 1 });
            gsap.to(mesh.rotation, { x:0, y:0, z:0, duration: 1 });
            gsap.to(mesh.scale, { x:3, y:3, z:3, duration: 1 });
        }

        function handleUpload(e) {
            const files = Array.from(e.target.files);
            let idx = 0;
            files.forEach(file => {
                if(idx >= photoMeshes.length) return;
                new THREE.TextureLoader().load(URL.createObjectURL(file), (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    photoMeshes[idx].material.map = tex;
                    photoMeshes[idx].material.needsUpdate = true;
                    idx++;
                });
            });
        }

        async function setupWebcam() {
            const video = document.getElementById('webcam');
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
            video.srcObject = stream;
            return new Promise(r => video.onloadeddata = r);
        }
        async function setupMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
        }
        function detectGesture(landmarks) {
            const lm = landmarks[0];
            const palmX = 1-lm[9].x, palmY = lm[9].y;
            const cursor = document.getElementById('hand-cursor');
            cursor.style.display='block'; cursor.style.left=(palmX*100)+'%'; cursor.style.top=(palmY*100)+'%';
            
            const wrist = lm[0];
            const tips = [lm[8],lm[12],lm[16],lm[20]];
            const avgDist = tips.reduce((s,t) => s+Math.hypot(t.x-wrist.x,t.y-wrist.y,t.z-wrist.z),0)/4;
            const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y, lm[4].z-lm[8].z);
            const now = Date.now();
            
            if (now-gestureCooldown > 800) {
                if(avgDist < 0.28) { // Fist
                    if(state!=='TREE'){ switchState('TREE'); gestureCooldown=now;} 
                    cursor.style.borderColor='red';
                }
                else if(pinchDist < 0.08) { // Pinch
                    mouse.x=(palmX*2)-1; mouse.y=-(palmY*2)+1;
                    raycaster.setFromCamera(mouse,camera);
                    const intersects=raycaster.intersectObjects(photoMeshes);
                    if(intersects.length>0){ zoomToPhoto(intersects[0].object); gestureCooldown=now; }
                    cursor.style.borderColor='green';
                }
                else if(avgDist > 0.45 && state==='TREE'){ // Open
                    switchState('SCATTER'); gestureCooldown=now; 
                    cursor.style.borderColor='gold';
                }
            }
            if(state==='SCATTER' && avgDist>0.4) {
                gsap.to(scene.rotation, {y: (palmX-0.5)*3, x: (palmY-0.5)*0.5, duration: 1});
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            const video = document.getElementById('webcam');
            if (handLandmarker && video.currentTime > 0) {
                const res = handLandmarker.detectForVideo(video, performance.now());
                if (res.landmarks && res.landmarks.length) detectGesture(res.landmarks);
                else document.getElementById('hand-cursor').style.display = 'none';
            }

            if(state === 'TREE') {
                scene.rotation.y += 0.002;
                scene.position.y = Math.sin(time*0.5)*0.5; 
            }

            activeLights.forEach(l => {
                const i = 0.5 + Math.sin(time * l.speed + l.phase) * 0.5;
                l.mesh.material.color.setHSL(0.1, 0.8, 0.5 + i*0.5); 
            });

            if(state === 'SCATTER') {
                ornaments.forEach(m => {
                    m.rotation.x += m.userData.rotSpeed.x;
                    m.rotation.y += m.userData.rotSpeed.y;
                });
            }

            if(snowSystem) {
                const pos = snowSystem.geometry.attributes.position;
                const vel = snowSystem.geometry.attributes.velocity;
                for(let i=0; i<800; i++) {
                    const idx = i*3;
                    pos.array[idx+1] -= vel.array[idx+1]; 
                    pos.array[idx] += Math.sin(time + pos.array[idx+1]*0.1) * vel.array[idx]; 
                    if(pos.array[idx+1] < -10) pos.array[idx+1] = 60;
                }
                pos.needsUpdate = true;
            }

            if(topStar) topStar.userData.halo.scale.setScalar(25 + Math.sin(time*3)*3);

            composer.render();
        }

        init();
    </script>
</body>
</html>
